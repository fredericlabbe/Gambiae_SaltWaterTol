###########################################################################################################
# Script: Define helpful functions to summarize the divergence times estimated by the A00 analysis of BPP #
# Author: Frederic Labbe                                                                                  #
# Date: 20/06/2019                                                                                        #
# Affiliations: University of Notre Dame & University of Groningen                                        #
###########################################################################################################

######################################
# The relative divergence time (Tau) #

# This function calculates some descriptive statistics (e.g. mean and median) of the relative divergence times (Tau). 
# data: a file containing the results generated by the A00 analysis of BPP (i.e. *.msmc.txt).
RelDivTime <- function(data) {
  Nodes <- as.vector(colnames(data %>% dplyr:: select(starts_with("tau"))))                     # Extract the node names.
  DivTime <- data.frame(Stat = c("mean", "median", "S.D", "min", "max", "2.5%", "97.5%"))       # Create a empty dataframe (useful for the next loop).
  l = 2                                                                                         # Create l starting at two (useful for the iterations in the next loop).
  for (i in Nodes) {                                                                            # For each node:
    DivTime[1, l] = mean(eval(parse(text = paste("data$", i, sep = ""))))                       # Calculate the mean.
    DivTime[2, l] = median(eval(parse(text = paste("data$", i, sep = ""))))                     # Calculate the median.
    DivTime[3, l] = sd(eval(parse(text = paste("data$", i, sep = ""))))                         # Calculate the standard deviation.
    DivTime[4, l] = min(eval(parse(text = paste("data$", i, sep = ""))))                        # Calculate the minimum.
    DivTime[5, l] = max(eval(parse(text = paste("data$", i, sep = ""))))                        # Calculate the maximum.
    DivTime[6, l] = quantile(eval(parse(text = paste("data$", i, sep = ""))), 0.025, na.rm = T) # Calculate the 2.5% quantile.
    DivTime[7, l] = quantile(eval(parse(text = paste("data$", i, sep = ""))), 0.975, na.rm = T) # Calculate the 97.5% quantile.
    colnames(DivTime)[l] <- gsub(x = i, pattern = "tau_", replacement = "")                     # Change column name.
    l = l + 1                                                                                   # Adds 1 to l to avoid the overwriting in the vector.
  }
  return(DivTime)
}

###############################################
# The absolute divergence time in generations #

# This function calculates some descriptive statistics (e.g. mean and median) of the absolute divergence times in generations. 
# data: a file containing the results generated by the A00 analysis of BPP (i.e. *.msmc.txt).
# MutRate: the mutation rate (e.g. 2.8e-09).
AbsDivTimeGen <- function(data, MutRate) {
  Nodes <- as.vector(colnames(data %>% dplyr:: select(starts_with("tau"))))                               # Extract the node names.
  DivTime <- data.frame(Stat = c("mean", "median", "S.D", "min", "max", "2.5%", "97.5%"))                 # Create a empty dataframe (useful for the next loop).
  l = 2                                                                                                   # Create l starting at two (useful for the iterations in the next loop).
  for (i in Nodes) {                                                                                      # For each node:
    DivTime[1, l] = mean(eval(parse(text = paste("data$", i, sep = "")))) / MutRate                       # Calculate the mean.
    DivTime[2, l] = median(eval(parse(text = paste("data$", i, sep = "")))) / MutRate                     # Calculate the median.
    DivTime[3, l] = sd(eval(parse(text = paste("data$", i, sep = "")))) / MutRate                         # Calculate the standard deviation.
    DivTime[4, l] = min(eval(parse(text = paste("data$", i, sep = "")))) / MutRate                        # Calculate the minimum.
    DivTime[5, l] = max(eval(parse(text = paste("data$", i, sep = "")))) / MutRate                        # Calculate the maximum.
    DivTime[6, l] = quantile(eval(parse(text = paste("data$", i, sep = ""))), 0.025, na.rm = T) / MutRate # Calculate the 2.5% quantile.
    DivTime[7, l] = quantile(eval(parse(text = paste("data$", i, sep = ""))), 0.975, na.rm = T) / MutRate # Calculate the 97.5% quantile.
    colnames(DivTime)[l] <- gsub(x = i, pattern = "tau_", replacement = "")                               # Change column name.
    l = l + 1                                                                                             # Adds 1 to l to avoid the overwriting in the vector.
  }
  return(DivTime)
}

#########################################
# The absolute divergence time in years #

# This function calculates some descriptive statistics (e.g. mean and median) of the absolute divergence times in years. 
# data: a file containing the results generated by the A00 analysis of BPP (i.e. *.msmc.txt).
# MutRate: the mutation rate (e.g. 2.8e-09).
# Gen: the number of generations per year (e.g. 11).
AbsDivTimeYea <- function(data, MutRate, Gen) {
  Nodes <- as.vector(colnames(data %>% dplyr:: select(starts_with("tau"))))                                       # Extract the node names.
  DivTime <- data.frame(Stat = c("mean", "median", "S.D", "min", "max", "2.5%", "97.5%"))                         # Create a empty dataframe (useful for the next loop).
  l = 2                                                                                                           # Create l starting at two (useful for the iterations in the next loop).
  for (i in Nodes) {                                                                                              # For each node:
    DivTime[1, l] = (mean(eval(parse(text = paste("data$", i, sep = "")))) / MutRate) / Gen                       # Calculate the mean.
    DivTime[2, l] = (median(eval(parse(text = paste("data$", i, sep = "")))) / MutRate) / Gen                     # Calculate the median.
    DivTime[3, l] = (sd(eval(parse(text = paste("data$", i, sep = "")))) / MutRate) / Gen                         # Calculate the standard deviation.
    DivTime[4, l] = (min(eval(parse(text = paste("data$", i, sep = "")))) / MutRate) / Gen                        # Calculate the minimum.
    DivTime[5, l] = (max(eval(parse(text = paste("data$", i, sep = "")))) / MutRate) / Gen                        # Calculate the maximum.
    DivTime[6, l] = (quantile(eval(parse(text = paste("data$", i, sep = ""))), 0.025, na.rm = T) / MutRate) / Gen # Calculate the 2.5% quantile.
    DivTime[7, l] = (quantile(eval(parse(text = paste("data$", i, sep = ""))), 0.975, na.rm = T) / MutRate) / Gen # Calculate the 97.5% quantile.
    colnames(DivTime)[l] <- gsub(x = i, pattern = "tau_", replacement = "")                                       # Change column name.
    l = l + 1                                                                                                     # Adds 1 to l to avoid the overwriting in the vector.
  }
  return(DivTime)
}
